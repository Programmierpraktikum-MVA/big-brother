# @Author: Julius U. Heller <thekalk>
# @Date:   2021-05-17T16:09:26+02:00
# @Project: ODS-Praktikum-Big-Brother
# @Filename: __init__.py
# @Last modified by:   Julius U. Heller
# @Last modified time: 2021-06-21T13:27:48+02:00
import os
from sys import stdout
import sys
import click

sys.path.append(os.path.join(os.path.dirname(__file__),".."))
from flask import Flask, Response, render_template, request
from flask_socketio import SocketIO, emit
#from flask_login import LoginManager
import flask_login
from app.utils import base64_to_pil_image, pil_image_to_base64
from config import Config
from app.user import BigBrotherUser


import multiprocessing as mp
#from app.camera import Camera


#Tells python where to search for modules
sys.path.append(os.path.join(os.path.dirname(__file__), '..','..','WiReTest'))
sys.path.append(os.path.join(os.path.dirname(__file__), '..','..','FaceRecognition','haar_and_lbph'))
sys.path.append(os.path.join(os.path.dirname(__file__), '..','..','FaceRecognition'))
sys.path.append(os.path.join(os.path.dirname(__file__), '..','..','DBM'))
from modifiedFaceRecog import recogFace
from face_rec_main import train_add_faces, authorize_faces
from main import load_images as load_test_imgs
import FaceDetection
#from app import routes

from flask import render_template, flash, redirect, url_for

#kim: kommt bald weg
from app.forms import LoginForm, CreateForm, LoginCameraForm
#kim: neuer import
from app.forms import SignUpForm, SignInForm, CameraForm

import ssl
from werkzeug.utils import secure_filename
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
import pickle
import uuid
import DatabaseManagement as DBM
import matplotlib as mpl
import cv2
import time
import logging
import base64
import io
import traceback
from imageio import imread
from PIL import Image
import copy
#from ..app import modifiedFaceRecog


#h2938366.stratoserver.net
print("Starting BigBrother")
startUpTime = time.time()
application = Flask(__name__)
application.config.from_object(Config)

application.logger.addHandler(logging.StreamHandler(stdout))
application.config['SECRET_KEY'] = 'secret!'
application.config['DEBUG'] = True
application.config['UPLOAD_FOLDER'] = application.instance_path
application.config['LOCALDEBUG'] = None

login_manager = flask_login.LoginManager()
login_manager.init_app(application)

global createPictures
createPictures = []

global authorizedFlag
global authorizedAbort
authorizedFlag = False
authorizedAbort = False

if os.environ.get('LOCALDEBUG') == "True":
    application.config['LOCALDEBUG'] = True
else:
    application.config['LOCALDEBUG'] = False
socketio = SocketIO(application)

#camera = Camera()

DB = DBM.wire_DB("h2938366.stratoserver.net")

print("Initialising all Users")
BigBrotherUserList = []
userDict = DB.getUsers().items()
userCount = len(userDict)
counter = 0
for key, value in DB.getUsers().items():

    BigBrotherUserList.append(BigBrotherUser(key,value,DB))

    counter += 1

    if round((counter / userCount) * 100) % 25 == 0:
        print("{}% finished...".format(round((counter / userCount) * 100)))

global emptypiccount
emptypiccount = 0

createPictures = []
print("Finished BigBrother init in {}s".format(time.time() - startUpTime))
@application.route("/logout")
@flask_login.login_required
def logout():
    form = SignInForm(request.form)
    flask_login.logout_user()
    return render_template('index.html', title='Home',form=form)
    #return redirect(url_for('index'))

@login_manager.user_loader
def load_user(user_id):
    print("loading user:",user_id,file=sys.stdout)

    if type(user_id) == tuple:
        user_id = user_id[0]

    loadedUser = None
    # return BigBrotherUser(user_id,DB.getUserWithId(user_id[0]))
    for bbUser in BigBrotherUserList:
        if bbUser.uuid == user_id:
            loadedUser = bbUser
            bbUser.sync()
            print("{} is Admin: {}".format(bbUser.name,bbUser.admin))
    return loadedUser

@application.route("/loginstep")
def loginstep():
    """
    DB.DBCursor.execute("SELECT * FROM shared.login_table WHERE is_logged_in = false")

    ret =  DB.DBCursor.fetchall()

    for la in ret:
        username = DB.getUserWithId(la[0])
        thisUser = BigBrotherUser(la[0], username, DB)
        flask_login.login_user(thisUser)
        print("Loggin User : {}".format(thisUser.name))

        DB.DBCursor.execute("UPDATE shared.login_table SET is_logged_in = true WHERE user_uuid = '{}'".format(la[0]))

    """
    #thisUser = BigBrotherUser(user['uuid'], user['username'], DB)
    flask_login.login_user(user['bbUser'])
    print("Loggin User : {}".format(user['bbUser'].name))

    return render_template("validationauthenticated.html")



@application.route("/rejection")
def rejection():
    #print(application.config['LOCALDEBUG'])
    #Dummy Form
    form = CameraForm()
    rejectionDict = {

                        'reason' : 'Unknown',
                        'redirect' : 'create',
                        'redirectPretty' : 'Zur端ck zur Registrierung',
                    }
    return render_template('rejection.html',  rejectionDict = rejectionDict, title='Reject', form=form)

@application.route("/validationsignup")
def validationsignup():
    #print(application.config['LOCALDEBUG'])
    #Dummy Form
    form = CameraForm()

    user_uuid = DB.getUser(user)

    if user_uuid:

        BigBrotherUserList.append(BigBrotherUser(user_uuid,user,DB))

        print("Created UserObject '{}' with uuid: {}".format(user,user_uuid),file=sys.stdout)

        return render_template('validationsignup.html', name=user)

    return render_template('index.html', BigBrotherUserList = BigBrotherUserList,form = form)

@application.route("/team")
def team():
    #print(application.config['LOCALDEBUG'])
    return render_template("team.html")

@application.route("/algorithms")
def algorithms():
    return render_template("algorithms.html")

@application.route("/userpage")
def userpage():

    display_uuid = request.args.get('usr', default = 1, type = str)
    displayUser = None
    for user in BigBrotherUserList:
        if user.uuid == display_uuid:
            displayUser = user

    return render_template("userpage.html", BigBrotherUserList = BigBrotherUserList,displayUser=displayUser)


#@application.route('/index')
@application.route('/',methods=['GET', 'POST'])
def index():
    form = None
    if request.method == 'POST':
        #form = CameraForm()
        return logincamera()

    """
    print("Request Form:",request.form)
    print("Request files",request.files)
    form = SignInForm(request.form)
    rejectionDict = {
                        'reason' : 'Unknown',
                        'redirect' : 'login',
                        'redirectPretty' : 'Zur端ck zur Anmeldung',
                    }
    if request.method == 'POST' and form.validate():
        flash('Thanks for logging in')
        user = {
                    'username': form.name.data,
                    'pic' : request.files['pic']
                }
        user_uuid = DB.getUser(user['username'])
        if user_uuid:
            user_uuid =uuid.UUID(user_uuid[0])
            f = user['pic']
            filename = secure_filename(f.filename)
            file_path = os.path.join(application.instance_path, filename)
            f.save(file_path)
            result = authenticatePicture(user,np.asarray(cv2.imread(file_path)))
            if result:
                thisUser = BigBrotherUser(user_uuid,user['username'],DB)
                flask_login.login_user(thisUser)
                return render_template('validationauthenticated.html')
            else:
                return render_template('rejection.html',  rejectionDict = rejectionDict, title='Sign In', form=form)
        else:
            print("'{}' not found!".format(user['username'],DB),file=sys.stdout)
            rejectionDict['reason'] = "'{}' not found!".format(user['username'])
            return render_template('rejection.html', rejectionDict = rejectionDict,  title='Sign In', form=form)

    """

        ##Registrierungs part###
    # form = SignUpForm(request.form)
    # if form.name == "reg":
    #     if request.method == 'POST' and form.validate():
    #         rejectionDict = {
    #             'reason': 'Unknown',
    #             'redirect': 'create',
    #             'redirectPretty': 'Zur端ck zur Registrierung',
    #         }
    #         user = {
    #             'username': form.name.data,
    #             'pic1': request.files['pic1'],
    #             'pic2': request.files['pic2'],
    #             'pic3': request.files['pic3']
    #         }
    #         if not DB.getUser(user['username']):
    #             pictures = [user['pic1'], user['pic2'], user['pic3']]
    #             user_uuid = DB.register_user(user['username'])
    #             for pic in pictures:
    #                 filename = secure_filename(pic.filename)
    #                 file_path = os.path.join(application.instance_path, filename)
    #                 pic.save(file_path)
    #                 pic_array = cv2.imread(file_path)
    #                 pic_resized = cv2.resize(pic_array, dsize=(98, 116), interpolation=cv2.INTER_CUBIC)
    #                 pic_uuid = DB.insertTrainingPicture(np.asarray(pic_resized, dtype=np.float64), user_uuid)
    #                 print("Inserted Picture for user_uuid: '{}' with pic_uuid: {}".format(user_uuid, pic_uuid),
    #                       file=sys.stdout)
    #             print("Created User '{}' with uuid: {}".format(user['username'], user_uuid), file=sys.stdout)
    #         else:
    #             print("'{}' already exists!".format(user['username']), file=sys.stdout)
    #             rejectionDict['reason'] = "Benutzername '{}' nicht Verf端gbar".format(user['username'])
    #             return render_template('rejection.html', rejectionDict=rejectionDict, title='Reject', form=form)
    #         return render_template('validation.html', s='r', name=user['username'])
    #     else:
    #         flash('Error: All Fields are Required')

    return render_template('index.html', BigBrotherUserList = BigBrotherUserList,form = form)

@application.route('/login', methods=['GET', 'POST'])
def login():
    form = SignInForm(request.form)

    rejectionDict = {

                        'reason' : 'Unknown',
                        'redirect' : 'login',
                        'redirectPretty' : 'Zur端ck zur Anmeldung',
                    }


    # We need to check if 'Sign In' or 'Open Camera' got pressed
    # Activates when Sign in Button is pressed

    #print(request.method ,form.validate())
    #print(form.errors,file=sys.stdout)

    if request.method == 'POST' and form.validate():
        flash('Thanks for logging in')
        #print("test",file=sys.stdout)

        #Fetch Username

        #print(request.files,file=sys.stdout)

        user = {
                    'username': form.name.data,
                    'pic' : request.files['pic']
                }
        #print("test2",file=sys.stdout)

        #DatabaseManagement

        #
        #Verify user
        #Checks if username is in Database and fetches uuid
        user_uuid = DB.getUser(user['username'])

        if user_uuid:

            user_uuid =uuid.UUID(user_uuid[0])

            #Get Picture Path
            #print("test3",file=sys.stdout)
            f = user['pic']
            #print("test4",file=sys.stdout)
            filename = secure_filename(f.filename)
            file_path = os.path.join(application.instance_path, filename)

            #Save Picture
            #print("test5",file=sys.stdout)
            f.save(file_path)
            #print("test6",file=sys.stdout)

            result = authenticatePicture(user,np.asarray(cv2.imread(file_path)))

            if result:

                thisUser = BigBrotherUser(user_uuid,user['username'],DB)
                flask_login.login_user(thisUser)

                return render_template('validationauthenticated.html',  user=user)

            else:
                return render_template('rejection.html',  rejectionDict = rejectionDict, title='Sign In', form=form)
        else:
            print("'{}' not found!".format(user['username']),file=sys.stdout)
            rejectionDict['reason'] = "'{}' not found!".format(user['username'])
            return render_template('rejection.html', rejectionDict = rejectionDict,  title='Sign In', form=form)

    return render_template('login.html',  title='Sign In', form=form)


@application.route('/create', methods=['GET', 'POST'])
def create():
    #form = CreateForm()
    #form = SignUpForm()
    form = SignUpForm(request.form)
    #print(form.errors,file=sys.stdout)
    #print(request.method)
    #print(form.validate())
    #if form.validate_on_submit():
    if request.method == 'POST' and form.validate():
        #print("test2",file=sys.stdout)
        #flash('Thanks for logging in')

        rejectionDict = {

                            'reason' : 'Unknown',
                            'redirect' : 'create',
                            'redirectPretty' : 'Zur端ck zur Registrierung',
                        }

        #print("test6",file=sys.stdout)

        #print(request.files,file=sys.stdout)

        #print("test7",file=sys.stdout)
        user = {
                    'username': form.name.data,
                    'pic1' : request.files['pic1'],
                    'pic2' : request.files['pic2'],
                    'pic3' : request.files['pic3']
                }

        user_uuid = None
        #print(form.errors,file=sys.stdout)
        if not DB.getUser(user['username']):
            #print("test3",file=sys.stdout)
            #print(user['username'],file=sys.stdout)

            #Get Picture Path
            #pic_1 = form.picturefront.data
            #pic_2 = form.pictureleft.data
            #pic_3 = form.pictureright.data

            pictures = [user['pic1'],user['pic2'],user['pic3']]

            user_uuid = DB.register_user(user['username'])

            for pic in pictures:

                filename = secure_filename(pic.filename)
                print(pic.filename)
                file_path = os.path.join(application.instance_path, filename)

            #Save Picture

                pic.save(file_path)

                #print("test3",file=sys.stdout)

                pic_array = cv2.imread(file_path,0)

                pic_resized = cv2.resize(pic_array, dsize=(98, 116), interpolation=cv2.INTER_CUBIC)


                pic_uuid = DB.insertTrainingPicture(np.asarray(pic_resized, dtype=np.float64),user_uuid)

                print("Inserted Picture for user_uuid: '{}' with pic_uuid: {}".format(user_uuid,pic_uuid),file=sys.stdout)

            BigBrotherUserList.append(BigBrotherUser(user_uuid,user['username'],DB))
            #else:
                #print("'{}' not found!".format(user['username']),file=sys.stdout)
                #return render_template('rejection.html',  title='Sign In', form=form)



            print("Created User '{}' with uuid: {}".format(user['username'],user_uuid),file=sys.stdout)

        else:

            print("'{}' already exists!".format(user['username']),file=sys.stdout)

            rejectionDict['reason'] = "Benutzername '{}' nicht Verf端gbar".format(user['username'])

            return render_template('rejection.html',  rejectionDict = rejectionDict, title='Reject', form=form)


        return render_template('validationsignup.html', name=user['username'])
    else:
        flash('Error: All Fields are Required')
        #print("test5",file=sys.stdout)

    return render_template("create.html", form=form)

import queue
global WEBCAM_IMAGE_QUEUE_LOGIN
global WEBCAM_IMAGE_QUEUE_CREATE

WEBCAM_IMAGE_QUEUE_LOGIN = queue.Queue()
WEBCAM_IMAGE_QUEUE_CREATE = queue.Queue()

@socketio.on('input_image_create', namespace='/createWithCamera')
def queueImage_create(input):

    print("Putting Image...")
    WEBCAM_IMAGE_QUEUE_CREATE.put(input)

@socketio.on('start_transfer_create', namespace='/createWithCamera')
def webcamCommunication_create():
    global authorizedAbort
    global authorizedFlag
    global WEBCAM_IMAGE_QUEUE_CREATE

    emit('ack_transfer', {'foo': 'bar'}, namespace='/createWithCamera')
    print("ack_transfer...")
    while not authorizedFlag or not authorizedAbort:
        try:
            create_with_image( WEBCAM_IMAGE_QUEUE_CREATE.get(block=True, timeout=5) )
        except queue.Empty:
            print("Webcam Queue is Empty! Breaking!",file=sys.stdout)
            break

    WEBCAM_IMAGE_QUEUE_CREATE = queue.Queue()
    authorizedAbort = False
    authorizedFlag = False

@socketio.on('input_image_login', namespace='/webcamJS')
def queueImage_login(input):
    print("Putting Image...")
    WEBCAM_IMAGE_QUEUE_LOGIN.put(input)

@socketio.on('start_transfer_login', namespace='/webcamJS')
def webcamCommunication():
    global authorizedAbort
    global authorizedFlag
    global WEBCAM_IMAGE_QUEUE_LOGIN

    emit('ack_transfer', {'foo': 'bar'}, namespace='/webcamJS')
    print("ack_transfer...")
    while not authorizedFlag or not authorizedAbort:
        try:
            test_message( WEBCAM_IMAGE_QUEUE_LOGIN.get(block=True, timeout=5) )
        except queue.Empty:
            print("Webcam Queue is Empty! Breaking!",file=sys.stdout)
            break

    WEBCAM_IMAGE_QUEUE_LOGIN = queue.Queue()
    authorizedAbort = False
    authorizedFlag = False

#Retrieving Image from Client javascript side, analyze it and send it back
#Socket source from: https://github.com/dxue2012/python-webcam-flask
#@socketio.on('input image', namespace='/webcamJS')
def test_message(input):
    #form = LoginCameraForm()
    #user = {'username': form.username.data}
    #print(user)

    global authorizedAbort

    authorizedAbort = False

    print("Testing...")

    #CAUTION: test_message is called multiple times from the client (for every image).
    #Figure out how many pics are needed and then close socket

    #print("[SOCKET DEBUG] 1",file=sys.stdout)
    input = input.split(",")[1]

    #camera.enqueue_input(input)
    image_data = input # Do your magical Image processing here!!

    #user is global (line 388), use it with cv2_img for authentication
    #OpenCV part decode and encode
    img = imread(io.BytesIO(base64.b64decode(image_data)))

    cutImg = FaceDetection.cut_rectangle(copy.deepcopy(img))

    cv2_img = FaceDetection.make_rectangle(img)



    #TODO Authentication with cv2_img and users
    #print(type(np.asarray(img)))




    cv2.imwrite("reconstructed.jpg", cv2_img)

    retval, buffer = cv2.imencode('.jpg', cv2_img)

    b = base64.b64encode(buffer)

    b = b.decode()

    image_data = "data:image/jpeg;base64," + b


    #print("OUTPUT " + image_data)

    user["isWorking"] = False

    #camera.enqueue_input(base64_to_pil_image(input))
    #res = authenticatePicture(user,np.asarray(img))
    #print(type(cutImg))
    if len(cutImg) < len(img) and len(cutImg) > 50:
        res = authenticatePicture(user,np.asarray(cutImg))

        print(res)

        if res:
            #socketio.disconnect()
            #thisUser = BigBrotherUser(user['uuid'], user['username'], DB)
            #flask_login.login_user(thisUser)
            #print("logged in")

            authorizedAbort = True

            DB.update_login(user_uuid=user['uuid'],
            time = user['login_attempt_time'],
            inserted_pic_uuid=res)
            DB.commit()

            emit('redirect', {'url' : '/loginstep'});
            return
    else:
        print("redirect")
        if isStreamEmpty():
            authorizedAbort = True
            print("redirect2")
            emit('redirect', {'url' : '/rejection'});


    print("Next Image...")

    emit('out-image-event', {'image_data': image_data}, namespace='/webcamJS')

#Retrieving Image from Client javascript side, analyze it and send it back
#Socket source from: https://github.com/dxue2012/python-webcam-flask
#Used for Registration
@socketio.on('input image', namespace='/createWithCamera')
def create_with_image(input):
    #form = LoginCameraForm()
    #user = {'username': form.username.data}
    global createPictures

    global authorizedAbort

    authorizedAbort = False

    #CAUTION: test_message is called multiple times from the client (for every image).
    #Figure out how many pics are needed and then close socket

    #print("[SOCKET DEBUG] 1",file=sys.stdout)
    input = input.split(",")[1]

    #camera.enqueue_input(input)
    image_data = input # Do your magical Image processing here!!

    #user is global (line 388), use it with cv2_img for authentication
    #OpenCV part decode and encode
    img = imread(io.BytesIO(base64.b64decode(image_data)))
    #mpl.pyplot.imshow(img)
    #mpl.pyplot.show()

    cutImg = np.asarray(FaceDetection.cut_rectangle(copy.deepcopy(img)))

    #print("Laenge CutImg: ",len(cutImg))
    #print("Laenge Img: ",len(img))

    cv2_img = FaceDetection.make_rectangle(img)

    cv2.imwrite("reconstructed.jpg", cv2_img)

    retval, buffer = cv2.imencode('.jpg', cv2_img)

    b = base64.b64encode(buffer)

    b = b.decode()

    image_data = "data:image/jpeg;base64," + b
    #socket.disconnect()
    #print(len(createPictures))
    #print(len(cutImg))

    #print("Check : {} and  {} <= 5 and {} > 40".format(cutImg.all(),len(createPictures),len(cutImg)))
    print("Check : {} < 5, {} < {}, {} > 50".format(len(createPictures),len(cutImg),len(img),len(cutImg)))
    print(len(createPictures) < 5 and len(cutImg) < len(img) and len(cutImg) > 50)
    if len(createPictures) < 5 and len(cutImg) < len(img) and len(cutImg) > 50:


        createPictures.append(cutImg)
        #mpl.pyplot.imshow(cutImg)
        #mpl.pyplot.show()

        if len(createPictures) >= 5:

            authorizedAbort = True

            registerUser(user, createPictures)

            emit('redirect', {'url' : '/validationsignup'})

        else:

            emit('out-image-event', {'image_data': image_data}, namespace='/createWithCamera')
    else:
        if isStreamEmpty():
            authorizedAbort = True
            emit('redirect', {'url' : '/rejection'});


    """

    if piccount == 0:
        pic_1 = cutImg
        createPictures.append(pic_1)
        piccount = piccount +1

        emit('out-image-event', {'image_data': image_data}, namespace='/createWithCamera')


    elif piccount == 1:
        pic_2 = cutImg
        createPictures.append(pic_2)
        piccount = piccount +1

        emit('out-image-event', {'image_data': image_data}, namespace='/createWithCamera')

    elif piccount == 2:
        pic_3 = cutImg
        createPictures.append(pic_3)

        piccount = 4
        print("Before registerUser gets Called")
        registerUser(user, pic_1, pic_2, pic_3)
        emit('redirect', {'url' : '/validationsignup'});
    """

    emit('out-image-event', {'image_data': image_data}, namespace='/createWithCamera')

#Socket Server side for login
@socketio.on('connect', namespace='/webcamJS')
def test_connect():
    application.logger.info("client connected")

#Socket Server side for registration
@socketio.on('connect', namespace='/createWithCamera')
def test_connect():
    application.logger.info("client connected")

@socketio.on("disconnect", namespace="/createWithCamera")
def disconnected():
    application.logger.info("Websocket client disconnected")

@application.route('/webcamJS', methods=['GET', 'POST'])
def webcamJS():
    return render_template('webcamJS.html', title='Camera')

@application.route('/webcamCreate', methods=['GET', 'POST'])
def webcamCreate():
    return render_template('webcamCreate.html', title='Camera')

@application.route('/logincamera', methods=['GET', 'POST'])
def logincamera():
    #print("logincam",file=sys.stdout)
    form = CameraForm(request.form)

    rejectionDict = {

                    'reason' : 'Unknown',
                    'redirect' : 'login',
                    'redirectPretty' : 'Zur端ck zur Anmeldung',
    }
                    # We need to check if 'Sign In' or 'Open Camera' got pressed
                    # Activates when Sign in Button is pressed

    #kim: brauchen wir noch nen if request.method == 'POST': ?

    #if form.validate():
    if request.method == 'POST' and form.validate():

        flash('Thanks for logging in')

            #Fetch Username

        global user
        user_uuid = DB.getUser(form.name.data)

        if not user_uuid:
            print("'{}' not found!".format(form.name.data),file=sys.stdout)
            rejectionDict['reason'] = "'{}' not found!".format(form.name.data)
            return render_template('rejection.html', rejectionDict = rejectionDict,  title='Sign In', form=form)

        bbUser = None

        for user in BigBrotherUserList:
            #print(user_uuid,"=",user.uuid)
            if user.uuid == user_uuid:
                bbUser = user
                break

        user = {
            'username': form.name.data,
            'isWorking' : False,
            'uuid' : user_uuid,
            'bbUser': bbUser
        }

        user['login_attempt_time'] = DB.login_user(user_uuid=user_uuid)

        return render_template('webcamJS.html', title='Camera')

    return render_template('logincamera.html', title='Login with Camera', form = form)

@application.route('/createcamera', methods=['GET', 'POST'])
def createcamera():
    #print("logincam",file=sys.stdout)
    form = CameraForm(request.form)

    global createPictures

    createPictures = []

    rejectionDict = {

                    'reason' : 'Unknown',
                    'redirect' : 'login',
                    'redirectPretty' : 'Zur端ck zur Anmeldung',
    }
                    # We need to check if 'Sign In' or 'Open Camera' got pressed
                    # Activates when Sign in Button is pressed

    #kim: brauchen wir noch nen if request.method == 'POST': ?

    #if form.validate():
    if request.method == 'POST' and form.validate():

        flash('Thanks for signing up')

            #Fetch Username

        global user
        username = form.name.data
        user_uuid = DB.getUser(username)

        if user_uuid:
            print("'{}' found!".format(form.name.data),file=sys.stdout)
            rejectionDict['reason'] = "'{}' already found!".format(form.name.data)
            return render_template('rejection.html', rejectionDict = rejectionDict,  title='Sign In', form=form)

        user = username

        return render_template('webcamCreate.html', title='Camera')

    return render_template('createcamera.html', title='Create an account', form = form)



def authenticatePicture(user,pic):

    global authorizedFlag
    authorizedFlag = False


    user_uuid = user['uuid']

    rejectionDict = {

                        'reason' : 'Unknown',
                        'redirect' : 'create',
                        'redirectPretty' : 'Zur端ck zur Registrierung',
                    }

    print(user)

    if user_uuid:

        print("Before: ",user_uuid)

        if type(user_uuid) == tuple:
            user_uuid = user_uuid[0]

        print("After: ",user_uuid)

        user_uuid = uuid.UUID(user_uuid)


        recogUsernames = recogFace([pic,user_uuid])


        #OpenCV Face Reg
        #TODO: put in other file to make this more clean

        #Train
        #imgs_raw, _, _, _ = load_test_imgs("./data/train/", user_uuid, ".png")
        '''
        Achtung das ist eigentlich nicht eure Funktion,
        Benutzt lieber das Datenbank modul daf端r
        Wir m端ssen noch bequatschen wie eurer Tables aussehen, habe das jetzt mal mit dem wire_DB datenbank manager gemacht.
         --Julius
        '''
        #Fetches picture belonging to user_uuid
        print("Running Query...",file=sys.stdout)
        t0 = time.time()
        imgs_raw ,uuids = DB.getTrainingPictures("""WHERE user_uuid = '{}'""".format(user_uuid))
        t1 = time.time()
        print("Took : {}s".format(t1-t0),file=sys.stdout)



        imgs_train = []
        resized_imgs = []
        for im in imgs_raw:
            norm_im = cv2.normalize(src=im, dst=None, alpha=0, beta=255, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_8U)
            imgs_train.append(norm_im)
            #resized_imgs.append(cv2.resize(im,dsize=(98,116), interpolation=cv2.INTER_CUBIC))
            float32_im = np.float32(im)
            im_RGB = cv2.cvtColor((float32_im / 256).astype('uint8'), cv2.COLOR_BGR2RGB)
            resized_imgs.append(im_RGB)


        #use temporary integer ID to train a completely new model and check if it recognized the same person in authorisation login picture
        # Muss das eine Integer User Id sein? K旦nnten wir auch die UUIDs aus der Datenbank benutzen?
        # Oder Zumindest eine eindeutige Umwandlung von UUID in Integer ID programmieren?
        # user_uuid beinhaltet schon eine eideutige ID --Julius
        temp_ID = 22
        #print(temp_ID)
        train_add_faces(temp_ID, imgs_train, save_model=False)

        #Authorize: check if the training pitures are the same person as the given login picture
        #cv_test_img = cv2.imread(file_path)

        cv_result, dists = False, None

        cv_test_img = cv2.normalize(src=pic, dst=None, alpha=0, beta=255, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_8U)

        try:

            cv_result, dists = authorize_faces(temp_ID, [cv_test_img])

        except cv2.error:
            print("cv2 Algo failed!")
            pass

        #debug
        print(f'\nOpenCV result: \nmatch? {cv_result} \ndistances: {dists} \n')

        openface_result = False
        #try:
        #openface_result = FaceDetection.authorize_user(resized_imgs, pic)

        #print(f'openface Algo result: {openface_result}')
        #except Exception:
        #    print("openface Algo failed")
        #    pass

        #When Recognised goto validationauthenticated.html

        # Join wireprocess
        #Temporary approach

        #wireProcess.join()

        #recogUsernames = mpQueue.get()

        #print(recogUsernames)

        wireMatch = False

        print(recogUsernames)

        if user['username'] in recogUsernames:


            wireMatch = True


        #recogUsernames = returnQueue[0]

        algoScore = int(cv_result) * 60 + int(openface_result) * 20 + int(wireMatch) * 20


        #if user['username'] in recogUsernames:
        if algoScore >= 40:
            print("User : '{}' recognised!".format(user['username']),file=sys.stdout)
            print("AlgoScore : {}".format(algoScore))

            authorizedFlag = True

            return DB.insertTrainingPicture(pic,user_uuid)

            #rejectionDict['reason'] = "User : '{}' recognised!".format(user['username'])
            #return render_template('validationauthenticated.html', ra='a',  user=user)

            #return True

        else:

            authorizedFlag = False

            print("User : '{}' not recognised!".format(user['username'],file=sys.stdout))
            print("AlgoScore : {}".format(algoScore))

            #rejectionDict['reason'] = "User : '{}' not recognised!".format(user['username'])
            #return render_template('rejection.html',  rejectionDict = rejectionDict, title='Sign In', form=form)
            return False
    else:
        authorizedFlag = False
        print("'{}' not found!".format(user['username']),file=sys.stdout)
        #rejectionDict['reason'] = "'{}' not found!".format(user['username'])
        #return render_template('rejection.html', rejectionDict = rejectionDict,  title='Sign In', form=form)
        return False

def registerUser(username, pictures):
    user = {
                'username': username
            }
    user_uuid = None

    if not DB.getUser(username):

        #pictures = [user['pic1'],user['pic2'],user['pic3']]

        user_uuid = DB.register_user(username)

        for pic in pictures:


            pic_uuid = DB.insertTrainingPicture(np.asarray(pic, dtype=np.float64),user_uuid)

            print("Inserted Picture for user_uuid: '{}' with pic_uuid: {}".format(user_uuid,pic_uuid),file=sys.stdout)

    else:

            print("'{}' already exists!".format(username),file=sys.stdout)

            rejectionDict['reason'] = "Benutzername '{}' nicht Verf端gbar".format(username)

            #return render_template('rejection.html',  rejectionDict = rejectionDict, title='Reject', form=form)
            emit('redirect', {'url' : '/rejection'});

    #return render_template('validationsignup.html', name=user['username'])
    emit('redirect', {'url' : '/validationsignup'});
    return

def isStreamEmpty():
    global emptypiccount
    print("Empty: ",emptypiccount)
    if emptypiccount > 4:
        emptypiccount = 0
        return True
    else:
        emptypiccount = emptypiccount + 1
        return False


if __name__=='__main__':
    #
    # ENV Variable must be set!
    # Windows: set LOCALDEBUG=True/False
    # Linux: export LOCALDEBUG=True/False
    #
    #if app.config['LOCALDEBUG']:
     #   socketio.run(app)
    #else:
        #socketio.run(app, host='85.214.39.122', port='80', debug=True, ssl_context=('/etc/letsencrypt/live/h2938366.stratoserver.net/fullchain.pem','/etc/letsencrypt/live/h2938366.stratoserver.net/privkey.pem'))

        #socketio.run(app, host='0.0.0.0', port=80, debug=True)
#app.run()
        #app.run(host='85.214.39.122', port='80', ssl_context=('/etc/letsencrypt/live/h2938366.stratoserver.net/fullchain.pem','/etc/letsencrypt/live/h2938366.stratoserver.net/privkey.pem'))
        socketio.run(application, host='h2938366.stratoserver.net', port='80', debug=True, ssl_context=('fullchain.pem','privkey.pem'))
